#+title: Arrays

* TABLE OF CONTENTS :TOC:
- [[#238-move-zeroes][238. Move Zeroes]]
  - [[#description][Description]]
  - [[#examples][Examples]]
  - [[#submissions][Submissions]]
- [[#1431-kids-with-greatest-candies][1431. Kids With Greatest Candies]]
  - [[#description-1][Description]]
  - [[#examples-1][Examples]]
  - [[#submissions-1][Submissions]]
- [[#1470-shuffle-the-array][1470. Shuffle the Array]]
  - [[#description-2][Description]]
  - [[#examples-2][Examples]]
  - [[#constraints][Constraints]]
  - [[#submissions-2][Submissions]]
- [[#1929-concatenation-of-array][1929. Concatenation of Array]]
  - [[#description-3][Description]]
  - [[#examples-3][Examples]]
  - [[#constraints-1][Constraints]]
  - [[#submissions-3][Submissions]]

* 238. Move Zeroes
** Description
/Difficulty: Easy/

Given an integer array =nums=, move all =0= 's to the end of it while maintaining the relative order of the non-zero elements.

*Note*  that you must do this in-place without making a copy of the array.

** Examples
*Example 1:*

#+begin_src
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]

#+end_src

*Example 2:*

#+begin_src
Input: nums = [0]
Output: [0]

#+end_src

*Constraints:*

- ~1 <= nums.length <= 10^{4}~
- ~-2^{31} <= nums[i] <= 2^{31} - 1~

 *Follow up:*  Could you minimize the total number of operations done?

** Submissions
Since the array can't be copied (i.e. using =filter=), my first thought was going
through the array and check if the current index is zero. If so, then I remove
it and place it at the end of the array

However, this solution didn't work for all cases

#+begin_src js
const zeroes = [0, 0, 1];
moveZeroes(zeroes)
return zeroes;

function moveZeroes(nums) {
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 0) {
            const zero = nums.splice(i, 1);
            nums.push(zero)
        }
    }
};
#+end_src

#+RESULTS:
| 0 | 1 | (0) |

The =i= would skip elements after they are swapped. I fixed this just by decrementing =i= after the swap operation

#+begin_src js
const zeroes = [0, 0, 1];
moveZeroes(zeroes)
return zeroes;

function moveZeroes(nums) {
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 0) {
            const zero = nums.splice(i, 1);
            nums.push(zero)
            i--;
        }
    }
};
#+end_src

#+RESULTS:
| 1 | (0) | (0) |

* 1431. Kids With Greatest Candies
** Description
There are =n= kids with candies. You are given an integer array =candies=, where
each =candies[i]= represents the number of candies the =i^{th}= kid has, and an
integer =extraCandies= , denoting the number of extra candies that you have.

Return /a boolean array/  =result=  /of length/  =n= /, where/  =result[i]=  /is/  =true=  /if,
after giving the/  =i^{th}=  /kid all the/  =extraCandies=  /, they will have the
*greatest*  number of candies among all the kids/ /, or/  =false=   /otherwise/ .

Note that *multiple* kids can have the *greatest*  number of candies.

** Examples
*Example 1:*

#+begin_src
Input: candies = [2,3,5,1,3], extraCandies = 3
Output: [true,true,true,false,true]
Explanation: If you give all extraCandies to:
- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.
- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.
- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.
- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.
- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.

#+end_src

*Example 2:*

#+begin_src
Input: candies = [4,2,1,1,2], extraCandies = 1
Output: [true,false,false,false,false]
Explanation: There is only 1 extra candy.
Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.

#+end_src

*Example 3:*

#+begin_src
Input: candies = [12,1,12], extraCandies = 10
Output: [true,false,true]
#+end_src

** Submissions
*** Submission 1
/Runtime: 65 ms/ - Beats 61.58%
/Memory: 44.1 MB/ - Beats 5.64%

This solution is too memory intensive

#+begin_src js
let candies = [2, 3, 5, 1, 3];
return kidsWithCandies(candies, 3);


/**
 * @param {number[]} candies
 * @param {number} extraCandies
 * @return {boolean[]}
 */
function kidsWithCandies(candies, extraCandies) {
  const candiesCopy = [...candies];
  const maxCandy = candies.sort((a, b) => a - b).reverse()[0];
  const results = [];
  for (let candy of candiesCopy) {
    results.push(candy + extraCandies >= maxCandy);
  }
  return results;
}
#+end_src

#+RESULTS:
| true | true | true | false | true |

*** Submission 2
/Runtime: 54 ms/ - Beats 95.86%
/Memory: 42.9 MB/ - Beats 11.58%

Way faster from having to do array operations. Also used the =max()= function.
Still pretty memory intensive though

#+begin_src js
let candies = [2, 3, 5, 1, 3];
return kidsWithCandies(candies, 3);

/**
 ,* @param {number[]} candies
 ,* @param {number} extraCandies
 ,* @return {boolean[]}
 ,*/
function kidsWithCandies(candies, extraCandies) {
  const maxCandy = Math.max(...candies);
  const results = [];
  for (let candy of candies) {
    results.push(candy + extraCandies >= maxCandy);
  }
  return results;
}


#+end_src

#+RESULTS:
| true | true | true | false | true |

*** Submission 3
/Runtime: 42 ms/ - Beats 99.92%
/Memory: 42.9 MB/ - Beats 11.58%

A lot faster. Still big use of memory

#+begin_src js
let candies = [2, 3, 5, 1, 3];
return kidsWithCandies(candies, 3);

/**
 ,* @param {number[]} candies
 ,* @param {number} extraCandies
 ,* @return {boolean[]}
 ,*/
function kidsWithCandies(candies, extraCandies) {
  const maxCandy = Math.max(...candies);
  return candies.map((candy) => candy + extraCandies >= maxCandy);
}
#+end_src

#+RESULTS:
| true | true | true | false | true |

* 1470. Shuffle the Array
** Description
Given the array =nums= consisting of =2n= elements in the form =[x_{1},x_{2},...,x_{n},y_{1},y_{2},...,y_{n}]= .

/Return the array in the form/ =[x_{1},y_{1},x_{2},y_{2},...,x_{n},y_{n}]= .

** Examples
*Example 1:*
#+begin_src js
Input: nums = [2,5,1,3,4,7], n = 3
Output: [2,3,5,4,1,7]
Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7].

#+end_src

*Example 2:*
#+begin_src js
Input: nums = [1,2,3,4,4,3,2,1], n = 4
Output: [1,4,2,3,3,2,4,1]

#+end_src

*Example 3:*
#+begin_src js
Input: nums = [1,1,2,2], n = 2
Output: [1,2,1,2]

#+end_src

** Constraints

- ~1 <= n <= 500~
- ~nums.length == 2n~
- ~1 <= nums[i] <= 10^3~

** Submissions
*** Submission 1
/Runtime: 74 ms/ - beats 56.76%
/Memory: 44.5 MB/ - beats 45.29%

Really easy. Just split the array at its middle point since all arrays should be
of even length

#+begin_src js
function shuffle(nums, n) {
  const firstHalf = nums.splice(0, n);
  const secondHalf = nums;
  const shuffled = [];
  for (let i = 0; i < firstHalf.length; i++) {
    shuffled.push(firstHalf[i]);
    shuffled.push(secondHalf[i]);
  }
  return shuffled;
}
#+end_src

*** Submission 2
/Runtime: 74 ms/ - beats 56.76%
/Memory: 44.5 MB/ - beats 45.29%

Simpler solution. TIL that you can have more parameters in a =push()= function

#+begin_src js
function shuffle(nums, n) {
  const shuffled = [];
  for (let i = 0; i < n; i++) {
    shuffled.push(nums[i], nums[i + n]);
  }
  return shuffled;
}
#+end_src

* 1929. Concatenation of Array
** Description
/Difficulty: Easy/

Given an integer array =nums= of length =n=, you want to create an array =ans= of length =2n= where ~ans[i] == nums[i]~ and ~ans[i + n] == nums[i]~ for ~0 <= i < n~  ( *0-indexed* ).

Specifically, =ans= is the *concatenation* of two =nums=  arrays.

Return /the array/  =ans= .

** Examples
*Example 1:*

#+begin_src js
Input: nums = [1,2,1]
Output: [1,2,1,1,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
#+end_src

*Example 2:*

#+begin_src js
Input: nums = [1,3,2,1]
Output: [1,3,2,1,1,3,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
- ans = [1,3,2,1,1,3,2,1]

#+end_src

** Constraints

- ~n == nums.length~
- ~1 <= n <= 1000~
- ~1 <= nums[i] <= 1000~

** Submissions
This was a really easy problem. Here's my first solution:

#+begin_src js
return getconcatenation([1, 2, 3, 4])

function getconcatenation(nums) {
  return [...nums, ...nums]
}
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 | 1 | 2 | 3 | 4 |

Turns out JavaScript also has a concatenation function =concat= that does the same
thing

#+begin_src js
return getconcatenation([1, 2, 3, 4])

function getconcatenation(nums) {
  return nums.concat(nums)
}

#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 | 1 | 2 | 3 | 4 |

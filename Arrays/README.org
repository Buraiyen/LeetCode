#+title: Arrays

* TABLE OF CONTENTS :TOC:
- [[#238-move-zeroes][238. Move Zeroes]]
  - [[#description][Description]]
  - [[#examples][Examples]]
  - [[#submissions][Submissions]]
- [[#1470-shuffle-the-array][1470. Shuffle the Array]]
  - [[#description-1][Description]]
  - [[#examples-1][Examples]]
  - [[#constraints][Constraints]]
  - [[#submissions-1][Submissions]]
- [[#1929-concatenation-of-array][1929. Concatenation of Array]]
  - [[#description-2][Description]]
  - [[#examples-2][Examples]]
  - [[#constraints-1][Constraints]]
  - [[#submissions-2][Submissions]]

* 238. Move Zeroes
** Description
/Difficulty: Easy/

Given an integer array =nums=, move all =0= 's to the end of it while maintaining the relative order of the non-zero elements.

*Note*  that you must do this in-place without making a copy of the array.

** Examples
*Example 1:*

#+begin_src
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]

#+end_src

*Example 2:*

#+begin_src
Input: nums = [0]
Output: [0]

#+end_src

*Constraints:*

- ~1 <= nums.length <= 10^{4}~
- ~-2^{31} <= nums[i] <= 2^{31} - 1~

 *Follow up:*  Could you minimize the total number of operations done?

** Submissions
Since the array can't be copied (i.e. using =filter=), my first thought was going
through the array and check if the current index is zero. If so, then I remove
it and place it at the end of the array

However, this solution didn't work for all cases

#+begin_src js
const zeroes = [0, 0, 1];
moveZeroes(zeroes)
return zeroes;

function moveZeroes(nums) {
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 0) {
            const zero = nums.splice(i, 1);
            nums.push(zero)
        }
    }
};
#+end_src

#+RESULTS:
| 0 | 1 | (0) |

The =i= would skip elements after they are swapped. I fixed this just by decrementing =i= after the swap operation

#+begin_src js
const zeroes = [0, 0, 1];
moveZeroes(zeroes)
return zeroes;

function moveZeroes(nums) {
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 0) {
            const zero = nums.splice(i, 1);
            nums.push(zero)
            i--;
        }
    }
};
#+end_src

#+RESULTS:
| 1 | (0) | (0) |

* 1470. Shuffle the Array
** Description
Given the array =nums= consisting of =2n= elements in the form =[x_{1},x_{2},...,x_{n},y_{1},y_{2},...,y_{n}]= .

/Return the array in the form/ =[x_{1},y_{1},x_{2},y_{2},...,x_{n},y_{n}]= .

** Examples
*Example 1:*
#+begin_src js
Input: nums = [2,5,1,3,4,7], n = 3
Output: [2,3,5,4,1,7]
Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7].

#+end_src

*Example 2:*
#+begin_src js
Input: nums = [1,2,3,4,4,3,2,1], n = 4
Output: [1,4,2,3,3,2,4,1]

#+end_src

*Example 3:*
#+begin_src js
Input: nums = [1,1,2,2], n = 2
Output: [1,2,1,2]

#+end_src

** Constraints

- ~1 <= n <= 500~
- ~nums.length == 2n~
- ~1 <= nums[i] <= 10^3~

** Submissions
*** Submission 1
/Runtime: 74 ms/ - beats 56.76%
/Memory: 44.5 MB/ - beats 45.29%

Really easy. Just split the array at its middle point since all arrays should be
of even length

#+begin_src js
function shuffle(nums, n) {
  const firstHalf = nums.splice(0, n);
  const secondHalf = nums;
  const shuffled = [];
  for (let i = 0; i < firstHalf.length; i++) {
    shuffled.push(firstHalf[i]);
    shuffled.push(secondHalf[i]);
  }
  return shuffled;
}
#+end_src

*** Submission 2
/Runtime: 74 ms/ - beats 56.76%
/Memory: 44.5 MB/ - beats 45.29%

Simpler solution. TIL that you can have more parameters in a =push()= function

#+begin_src js
function shuffle(nums, n) {
  const shuffled = [];
  for (let i = 0; i < n; i++) {
    shuffled.push(nums[i], nums[i + n]);
  }
  return shuffled;
}
#+end_src

* 1929. Concatenation of Array
** Description
/Difficulty: Easy/

Given an integer array =nums= of length =n=, you want to create an array =ans= of length =2n= where ~ans[i] == nums[i]~ and ~ans[i + n] == nums[i]~ for ~0 <= i < n~  ( *0-indexed* ).

Specifically, =ans= is the *concatenation* of two =nums=  arrays.

Return /the array/  =ans= .

** Examples
*Example 1:*

#+begin_src js
Input: nums = [1,2,1]
Output: [1,2,1,1,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
#+end_src

*Example 2:*

#+begin_src js
Input: nums = [1,3,2,1]
Output: [1,3,2,1,1,3,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
- ans = [1,3,2,1,1,3,2,1]

#+end_src

** Constraints

- ~n == nums.length~
- ~1 <= n <= 1000~
- ~1 <= nums[i] <= 1000~

** Submissions
This was a really easy problem. Here's my first solution:

#+begin_src js
return getconcatenation([1, 2, 3, 4])

function getconcatenation(nums) {
  return [...nums, ...nums]
}
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 | 1 | 2 | 3 | 4 |

Turns out JavaScript also has a concatenation function =concat= that does the same
thing

#+begin_src js
return getconcatenation([1, 2, 3, 4])

function getconcatenation(nums) {
  return nums.concat(nums)
}

#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 | 1 | 2 | 3 | 4 |
